\chapter{Modeling with connected matchings}

In this chapter, we will look at the sorts of real world problems that can be modeled using connected matchings in graphs.  Typically, such a problem will be of a ``matching {\it plus}'' kind; a system of pairings that must satisfy some additional requirement.  The NP-hardness of finding maximum connected matchings in general graphs means that we must also look at some experimental results of solving typical examples of these kinds of models in order to gauge the scale at which they remain tractable.
    
	
\section{Bipartite graphs}
	In a typical bipartite matching problem, we are attempting to perform an {\it assignment}.  We are given a collection $A$ of one type of object, a collection $B$ of a second type of object, and a set of feasible assignments
of objects from $B$ to each object in $A$.  We assume that only one object may be assigned to another object.  The problem is to choose from among these possible assignments a set of {\it actual} assignments that maximizes some desirable property.
	
	in the case of {\it connected} matchings, we have added another requirement.  The assignment must be done in such a way that among the objects in any two assigned pairs, there is some other, unused feasible assignment.  This may model redundancy, flexibility, interconnectivity, proximity, or some other quality we wish to demand of the chosen matching.   
	\subsection{Cloud administration}

	Let us draw up a hypothetical problem that highlights the above description.  Suppose we are administering a cloud-based application. Broadly speaking, the architecture of the application consists of {\it servers} which store and process data and {\it clients} which deliver content and recieve commands from end users.  At any given time, each client is logged in to the small subset of servers needed to carry out a particular task.

Suppose that we want to allow limited and moderated client-client communication.  For privacy, security, or other reasons we do not wish to allow all clients logged in to a given server to send and receive messages from each other.  In fact, we will require that one side of any transmission be a superuser.   This privileged client serves to moderate the communication.  However, we do wish for {\it any} two clients logged into {\it any} of the servers to be able to get a message from one to the other both as quickly as possible. 

We can begin with a matching problem: how do we assign a privileged (logged-in) client to each server?  Each superuser will administer its assigned server, in addition to transmitting messages among clients logged into that server.  By itself, this question will provide us with a collection of superusers that can moderate all messages on any given server.  Furthermore, each message will pass through only one intermediary.  This is close to what we want, but so far we cannot guarantee that users not mutually logged into any particular server can communicate.

To fully meet our requirements, we must ensure that there is a ``safe'' path between any two servers.  To meet them and ensure rapid communication, we should ensure that any pair of superusers are both logged into some server and can thus pass messages.  When we make an assignment that does so, we have actually found a {\it connected} matching.  It is also not difficult to see that any connected matching in the server-client bigraph represents a satisfactory assignment of servers to superusers.

An interesting feature of this particular example is an asymmetry in scaling.  As the application grows in users, each individual server machine will be able to serve greater numbers of clients, provided that the software involved is well designed and scalable.  If the number of servers remains essentially fixed as the application grows, then we will still be able to efficiently identify large connected matchings in the server graph.

	\subsection{The margin shop problem}


\section{General graphs}

Sometimes we may encounter a matching-type problem with only one type of object modeled by nodes.  In this case, we cannot assume that the appropriate graph model is bipartite.  The relation we wish to model with edges in the graph can be assumed to be non-transitive, as otherwise the graph model degenerates into a collection of disconnected cliques.
	\subsection{Partnership assignments}
One type of ``assignment between equals'' we encounter in the real world is that of working partnerships.  In any organization, we can model individuals as vertices in a graph and use edges to represent some type of advantageous (non-transitive) working relationship.  By identifying a connected matching, we collect a set of possible partnerships wherein each pair of partners has the advantageous relationship and any two pairs $A$ and $B$ have an individual from pair $A$ that has the advantageous relationship with some individual from pair $B$,

Let us see how this might work in a high school mathematics classroom.  Suppose we model the students in the class as vertices and place a edge between vertices if the corresponding students have the same homeroom teacher.  We want to assign a project 
	

